#include "CDCSmearer.h"

//-----------
// cdc_config_t  (constructor)
//-----------
cdc_config_t::cdc_config_t(JEventLoop *loop) 
{
	// default values
	CDC_TDRIFT_SIGMA      = 0.0;
	CDC_TIME_WINDOW       = 0.0;
	CDC_PEDESTAL_SIGMA    = 0.0;
	CDC_THRESHOLD_FACTOR  = 0.0;
    CDC_CHARGE_TO_ADC_COUNTS = 1.;

    // temporary? this is a ballpark guess from Naomi (sdobbs, 8/28/2017)
    CDC_INTEGRAL_TO_AMPLITUDE = 1. / 29.;
 		
 	// load data from CCDB
 	jout << "get CDC/cdc_parms parameters from CCDB..." << endl;
    map<string, double> cdcparms;
    if(loop->GetCalib("CDC/cdc_parms", cdcparms)) {
    	jerr << "Problem loading CDC/cdc_parms from CCDB!" << endl;
    } else {
     	CDC_TDRIFT_SIGMA   = cdcparms["CDC_TDRIFT_SIGMA"]; 
 		CDC_TIME_WINDOW    = cdcparms["CDC_TIME_WINDOW"];
 		CDC_PEDESTAL_SIGMA = cdcparms["CDC_PEDESTAL_SIGMA"]; 
 		CDC_THRESHOLD_FACTOR = cdcparms["CDC_THRESHOLD_FACTOR"];
	}
	
 	jout << "get CDC/digi_scales parameters from CCDB..." << endl;
    map<string, double> digi_scales;
    if(loop->GetCalib("CDC/digi_scales", cdcparms)) {
    	jerr << "Problem loading CDC/digi_scales from CCDB!" << endl;
    } else {
     	CDC_CHARGE_TO_ADC_COUNTS = 1./cdcparms["CDC_ADC_ASCALE"]; 
	}
	
	// LOAD efficiency correction factors

	// first load some geometry information
	vector<unsigned int> Nstraws;
	int32_t runnumber = loop->GetJEvent().GetRunNumber();
    CalcNstraws(loop, runnumber, Nstraws);
    //unsigned int Nrings = Nstraws.size();

	// then load the CCDB table
	vector<double> raw_table;
	if(loop->GetCalib("CDC/wire_mc_efficiency", raw_table)) {
    	jerr << "Problem loading CDC/wire_mc_efficiency from CCDB!" << endl;
    } else {
		// now fill the table
    	wire_efficiencies.resize( Nstraws.size() );

    	int ring = 0;
    	int straw = 0;

    	for (unsigned int channel=0; channel<raw_table.size(); channel++,straw++) {
        	// if we've hit the end of the ring, move on to the next
        	if (straw == (int)Nstraws[ring]) {
            	ring++;
            	straw = 0;
        	}

        	wire_efficiencies[ring].push_back( raw_table[channel] );
    	}
    }


	if(loop->GetCalib("CDC/hit_thresholds", raw_table)) {
    	jerr << "Problem loading CDC/hit_thresholds from CCDB!" << endl;
    } else {
		// now fill the table
    	wire_thresholds.resize( Nstraws.size() );

    	int ring = 0;
    	int straw = 0;

    	for (unsigned int channel=0; channel<raw_table.size(); channel++,straw++) {
        	// if we've hit the end of the ring, move on to the next
        	if (straw == (int)Nstraws[ring]) {
            	ring++;
            	straw = 0;
        	}

        	wire_thresholds[ring].push_back( raw_table[channel] );
    	}
    }

}

//------------------
// CalcNstraws
//------------------
void cdc_config_t::CalcNstraws(jana::JEventLoop *eventLoop, int32_t runnumber, vector<unsigned int> &Nstraws)
{
    DGeometry *dgeom;
    vector<vector<DCDCWire *> >cdcwires;

    // Get pointer to DGeometry object
    DApplication* dapp=dynamic_cast<DApplication*>(eventLoop->GetJApplication());
    dgeom  = dapp->GetDGeometry(runnumber);

    // Get the CDC wire table from the XML
    dgeom->GetCDCWires(cdcwires);

    // Fill array with the number of straws for each layer
    // Also keep track of the total number of straws, i.e., the total number of detector channels
    //maxChannels = 0;
    Nstraws.clear();
    for (unsigned int i=0; i<cdcwires.size(); i++) {
        Nstraws.push_back( cdcwires[i].size() );
        //maxChannels += cdcwires[i].size();
    }

    // clear up all of the wire information
    for (unsigned int i=0; i<cdcwires.size(); i++) {
        for (unsigned int j=0; j<cdcwires[i].size(); j++) {
            delete cdcwires[i][j];
        }
    }    
}


//-----------
// SmearEvent
//-----------
void CDCSmearer::SmearEvent(hddm_s::HDDM *record)
{
   /// Smear the drift times of all CDC hits.
   /// This will add cdcStrawHit objects generated by smearing values in the
   /// cdcStrawTruthHit objects that hdgeant outputs. Any existing cdcStrawHit
   /// objects will be replaced.

   double t_max = config->TRIGGER_LOOKBACK_TIME + cdc_config->CDC_TIME_WINDOW;
   // move to wire-dependent sparsification thresholds compared to an overall factor
   //double threshold = cdc_config->CDC_THRESHOLD_FACTOR * cdc_config->CDC_PEDESTAL_SIGMA; // for sparsification

   // Loop over all cdcStraw tags
   hddm_s::CdcStrawList straws = record->getCdcStraws();
   hddm_s::CdcStrawList::iterator iter;
   for (iter = straws.begin(); iter != straws.end(); ++iter) {
 
      // If the element already contains a cdcStrawHit list then delete it.
      hddm_s::CdcStrawHitList hits = iter->getCdcStrawHits();
      if (hits.size() > 0) {
         static bool warned = false;
         iter->deleteCdcStrawHits();
         if (!warned) {
            warned = true;
            cerr << endl;
            cerr << "WARNING: CDC hits already exist in input file! Overwriting!"
                 << endl << endl;
         }
      }

      // Create new cdcStrawHit from cdcStrawTruthHit information
      hddm_s::CdcStrawTruthHitList thits = iter->getCdcStrawTruthHits();
      hddm_s::CdcStrawTruthHitList::iterator titer;
      for (titer = thits.begin(); titer != thits.end(); ++ titer) {
         // correct simulation efficiencies 
		 if (config->APPLY_EFFICIENCY_CORRECTIONS
		 		&& !gDRandom.DecideToAcceptHit(cdc_config->GetEfficiencyCorrectionFactor(iter->getRing(), iter->getStraw())))
		 	continue;

         // Pedestal-smeared charge
         double q = titer->getQ() + gDRandom.SampleGaussian(cdc_config->CDC_PEDESTAL_SIGMA);
         double amplitude = q * cdc_config->CDC_CHARGE_TO_ADC_COUNTS * cdc_config->CDC_INTEGRAL_TO_AMPLITUDE;

         // Smear out the CDC drift time using the specified sigma.
         // This is for timing resolution from the electronics;
         // diffusion is handled in hdgeant.
         double t = titer->getT() + gDRandom.SampleGaussian(cdc_config->CDC_TDRIFT_SIGMA)*1.0e9;
         
         // per-wire threshold in ADC units
         double threshold = cdc_config->GetWireThreshold(iter->getRing(), iter->getStraw());
         if (t > config->TRIGGER_LOOKBACK_TIME && t < t_max && amplitude > threshold) {
            hits = iter->addCdcStrawHits();
            hits().setT(t);
            hits().setQ(q);
         }

         if (config->DROP_TRUTH_HITS) {
            iter->deleteCdcStrawTruthHits();
         }
      }
   }
}
