//
// hddm_s_merger.cc - Utility class for merging hits from two hddm_s element lists
//
// author: richard.t.jones at uconn.edu
// version: march 20, 2017
//
// notes:
// 1) Only hits information (ie. tags generated by mcsmear from simulation
//    truth information) are merged by the functions in this suite; all other
//    tags are ignored.
//
// 2) The merger functions overload the += operator for HDDM_ElementList and
//    HDDM_ElementLink objects. The destination and source elements in this
//    operation are assumed to belong to different HDDM records.
//
// 3) The merging operators maintain the intended ordering of hits elements
//    in the merged HDDM record. This is not strictly required by the hddm_s 
//    data model, but it is a good convention and makes sure that the origin
//    of any particular tag cannot feed forward and affect how it is used in
//    subsequent analysis.

#include <iostream>
#include <hddm_s_merger.h>

static thread_local double t_shift_ns(0);
static thread_local double cdc_min_delta_t_ns(25.);
static thread_local double fdc_min_delta_t_ns(25.);
static thread_local double stc_min_delta_t_ns(25.);
static thread_local double bcal_min_delta_t_ns(50.);
static thread_local double ftof_min_delta_t_ns(25.);
static thread_local double fcal_min_delta_t_ns(75.);
static thread_local double ccal_min_delta_t_ns(75.);
static thread_local double ps_min_delta_t_ns(25.);
static thread_local double psc_min_delta_t_ns(25.);
static thread_local double ttag_min_delta_t_ns(25.);
static thread_local double tpol_min_delta_t_ns(2500.);
static thread_local double fmwpc_min_delta_t_ns(400.);
static thread_local double fadc_counts_per_ns(16.);
static thread_local double tdc_counts_per_ns(16.13);

namespace hddm_s_merger {

   double get_t_shift_ns() {
      return t_shift_ns;
   }

   void set_t_shift_ns(double dt_ns) {
      t_shift_ns = dt_ns;
   }

   double get_cdc_min_delta_t_ns() {
      return cdc_min_delta_t_ns;
   }

   void set_cdc_min_delta_t_ns(double dt_ns) {
      cdc_min_delta_t_ns = dt_ns;
   }

   double get_fdc_min_delta_t_ns() {
      return fdc_min_delta_t_ns;
   }

   void set_fdc_min_delta_t_ns(double dt_ns) {
      fdc_min_delta_t_ns = dt_ns;
   }
      
   double get_stc_min_delta_t_ns() {
      return stc_min_delta_t_ns;
   }

   void set_stc_min_delta_t_ns(double dt_ns) {
      stc_min_delta_t_ns = dt_ns;
   }
      
   double get_bcal_min_delta_t_ns() {
      return bcal_min_delta_t_ns;
   }

   void set_bcal_min_delta_t_ns(double dt_ns) {
      bcal_min_delta_t_ns = dt_ns;
   }

   double get_ftof_min_delta_t_ns() {
      return ftof_min_delta_t_ns;
   }

   void set_ftof_min_delta_t_ns(double dt_ns) {
      ftof_min_delta_t_ns = dt_ns;
   }
      
   double get_fcal_min_delta_t_ns() {
      return fcal_min_delta_t_ns;
   }

   void set_fcal_min_delta_t_ns(double dt_ns) {
      fcal_min_delta_t_ns = dt_ns;
   }
      
   double get_ccal_min_delta_t_ns() {
      return ccal_min_delta_t_ns;
   }

   void set_ccal_min_delta_t_ns(double dt_ns) {
      ccal_min_delta_t_ns = dt_ns;
   }
      
   double get_ps_min_delta_t_ns() {
      return ps_min_delta_t_ns;
   }

   void set_ps_min_delta_t_ns(double dt_ns) {
      ps_min_delta_t_ns = dt_ns;
   }
      
   double get_psc_min_delta_t_ns() {
      return psc_min_delta_t_ns;
   }

   void set_psc_min_delta_t_ns(double dt_ns) {
      psc_min_delta_t_ns = dt_ns;
   }
      
   double get_ttag_min_delta_t_ns() {
      return ttag_min_delta_t_ns;
   }

   void set_ttag_min_delta_t_ns(double dt_ns) {
      ttag_min_delta_t_ns = dt_ns;
   }
      
   double get_tpol_min_delta_t_ns() {
      return tpol_min_delta_t_ns;
   }

   void set_tpol_min_delta_t_ns(double dt_ns) {
      tpol_min_delta_t_ns = dt_ns;
   }
      
   double get_fmwpc_min_delta_t_ns() {
      return fmwpc_min_delta_t_ns;
   }

   void set_fmwpc_min_delta_t_ns(double dt_ns) {
      fmwpc_min_delta_t_ns = dt_ns;
   }
      
   double get_fadc_counts_per_ns() {
      return fadc_counts_per_ns;
   }

   void set_fadc_counts_per_ns(double slope) {
      fadc_counts_per_ns = slope;
   }
      
   double get_tdc_counts_per_ns() {
      return tdc_counts_per_ns;
   }

   void set_tdc_counts_per_ns(double slope) {
      tdc_counts_per_ns = slope;
   }
      
}

hddm_s::HDDM &operator+=(hddm_s::HDDM &dst, hddm_s::HDDM &src)
{
   dst.getPhysicsEvents() += src.getPhysicsEvents();
   return dst;
}

hddm_s::PhysicsEventList &operator+=(hddm_s::PhysicsEventList &dst,
                                     hddm_s::PhysicsEventList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::PhysicsEventList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getHitViews() += iter->getHitViews();
   }
   return dst;
}

hddm_s::HitViewList &operator+=(hddm_s::HitViewList &dst,
                                hddm_s::HitViewList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::HitViewList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getCentralDCs() += iter->getCentralDCs();
      dst(0).getForwardDCs() += iter->getForwardDCs();
      dst(0).getStartCntrs() += iter->getStartCntrs();
      dst(0).getBarrelEMcals() += iter->getBarrelEMcals();
      dst(0).getForwardEMcals() += iter->getForwardEMcals();
      dst(0).getForwardTOFs() += iter->getForwardTOFs();
      dst(0).getComptonEMcals() += iter->getComptonEMcals();
      dst(0).getTaggers() += iter->getTaggers();
      dst(0).getPairSpectrometerFines() += iter->getPairSpectrometerFines();
      dst(0).getPairSpectrometerCoarses() += iter->getPairSpectrometerCoarses();
      dst(0).getTripletPolarimeters() += iter->getTripletPolarimeters();
      dst(0).getForwardMWPCs() += iter->getForwardMWPCs();
   }
   return dst;
}

hddm_s::CentralDCList &operator+=(hddm_s::CentralDCList &dst,
                                  hddm_s::CentralDCList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::CentralDCList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getCdcStraws() += iter->getCdcStraws();
   }
   return dst;
}

hddm_s::CdcStrawList &operator+=(hddm_s::CdcStrawList &dst,
                                 hddm_s::CdcStrawList &src)
{
   // order first by ring, then straw
   int iord = 0;
   hddm_s::CdcStrawList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int ring = iter->getRing();
      int straw = iter->getStraw();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getRing() > ring ||
             (dst(iord).getRing() == ring && dst(iord).getStraw() > straw))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getRing() < ring ||
             (dst(iord).getRing() == ring && dst(iord).getStraw() < straw))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() ||
          dst(iord).getRing() != ring || 
          dst(iord).getStraw() != straw)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setRing(ring);
         dst(iord).setStraw(straw);
      }
      dst(iord).getCdcStrawHits() += iter->getCdcStrawHits();
   }
   return dst;
}

hddm_s::CdcStrawHitList &operator+=(hddm_s::CdcStrawHitList &dst,
                                    hddm_s::CdcStrawHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::CdcStrawHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = cdc_min_delta_t_ns;
      double newQ = iter->getQ();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldQ = dst(iord - 1).getQ();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setQ(oldQ + newQ * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldQ = dst(iord).getQ();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setQ(newQ + oldQ * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setQ(newQ);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::ForwardDCList &operator+=(hddm_s::ForwardDCList &dst,
                                  hddm_s::ForwardDCList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::ForwardDCList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getFdcChambers() += iter->getFdcChambers();
   }
   return dst;
}

hddm_s::FdcChamberList &operator+=(hddm_s::FdcChamberList &dst,
                                   hddm_s::FdcChamberList &src)
{
   // order first by module, then layer
   int iord = 0;
   hddm_s::FdcChamberList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int layer = iter->getLayer();
      int module = iter->getModule();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getModule() > module ||
             (dst(iord).getModule() == module && dst(iord).getLayer() > layer))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getModule() < module ||
             (dst(iord).getModule() == module && dst(iord).getLayer() < layer))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() ||
          dst(iord).getModule() != module || 
          dst(iord).getLayer() != layer)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setModule(module);
         dst(iord).setLayer(layer);
      }
      dst(iord).getFdcAnodeWires() += iter->getFdcAnodeWires();
      dst(iord).getFdcCathodeStrips() += iter->getFdcCathodeStrips();
   }
   return dst;
}

hddm_s::FdcAnodeWireList &operator+=(hddm_s::FdcAnodeWireList &dst,
                                     hddm_s::FdcAnodeWireList &src)
{
   // order by anode wire
   int iord = 0;
   hddm_s::FdcAnodeWireList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int wire = iter->getWire();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getWire() > wire)
            --iord;
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getWire() < wire)
            ++iord;
         else
            break;
      }
      if (iord == dst.size() || dst(iord).getWire() != wire) {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setWire(wire);
      }
      dst(iord).getFdcAnodeHits() += iter->getFdcAnodeHits();
   }
   return dst;
}

hddm_s::FdcAnodeHitList &operator+=(hddm_s::FdcAnodeHitList &dst,
                                    hddm_s::FdcAnodeHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::FdcAnodeHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = fdc_min_delta_t_ns;
      double newDE = iter->getDE();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldDE = dst(iord - 1).getDE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setDE(oldDE + newDE * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldDE = dst(iord).getDE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setDE(newDE + oldDE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setDE(newDE);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::FdcCathodeStripList &operator+=(hddm_s::FdcCathodeStripList &dst,
                                        hddm_s::FdcCathodeStripList &src)
{
   // order by plane, then cathode strip 
   int iord = 0;
   hddm_s::FdcCathodeStripList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int plane = iter->getPlane();
      int strip = iter->getStrip();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getPlane() > plane ||
             (dst(iord).getPlane() == plane && dst(iord).getStrip() > strip))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getPlane() < plane ||
             (dst(iord).getPlane() == plane && dst(iord).getStrip() < strip))
            ++iord;
         else
            break;
      }
      if (iord == dst.size() || dst(iord).getPlane() != plane ||
                                dst(iord).getStrip() != strip)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setPlane(plane);
         dst(iord).setStrip(strip);
      }
      dst(iord).getFdcCathodeHits() += iter->getFdcCathodeHits();
   }
   return dst;
}

hddm_s::FdcCathodeHitList &operator+=(hddm_s::FdcCathodeHitList &dst,
                                      hddm_s::FdcCathodeHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::FdcCathodeHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = fdc_min_delta_t_ns;
      double newQ = iter->getQ();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldQ = dst(iord - 1).getQ();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setQ(oldQ + newQ * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldQ = dst(iord).getQ();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setQ(newQ + oldQ * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setQ(newQ);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::StartCntrList &operator+=(hddm_s::StartCntrList &dst,
                                  hddm_s::StartCntrList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::StartCntrList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getStcPaddles() += iter->getStcPaddles();
   }
   return dst;
}

hddm_s::StcPaddleList &operator+=(hddm_s::StcPaddleList &dst,
                                  hddm_s::StcPaddleList &src)
{
   // order by sector index
   int iord = 0;
   hddm_s::StcPaddleList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int sector = iter->getSector();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getSector() > sector)
            --iord;
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getSector() < sector)
            ++iord;
         else
            break;
      }
      if (iord == dst.size() || dst(iord).getSector() != sector) {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setSector(sector);
      }
      dst(iord).getStcHits() += iter->getStcHits();
   }
   return dst;
}

hddm_s::StcHitList &operator+=(hddm_s::StcHitList &dst,
                               hddm_s::StcHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::StcHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = stc_min_delta_t_ns;
      double newDE = iter->getDE();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldDE = dst(iord - 1).getDE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setDE(oldDE + newDE * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldDE = dst(iord).getDE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setDE(newDE + oldDE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setDE(newDE);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::BarrelEMcalList &operator+=(hddm_s::BarrelEMcalList &dst,
                                    hddm_s::BarrelEMcalList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::BarrelEMcalList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getBcalCells() += iter->getBcalCells();
   }
   return dst;
}

hddm_s::BcalCellList &operator+=(hddm_s::BcalCellList &dst,
                                 hddm_s::BcalCellList &src)
{
   // order by module, then layer, then sector
   int iord = 0;
   hddm_s::BcalCellList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int module = iter->getModule();
      int sector = iter->getSector();
      int layer = iter->getLayer();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getModule() > module ||
             (dst(iord).getModule() == module && dst(iord).getLayer() > layer)
             || (dst(iord).getModule() == module && 
                 dst(iord).getLayer() == layer && 
                 dst(iord).getSector() > sector))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getModule() < module ||
             (dst(iord).getModule() == module && dst(iord).getLayer() < layer)
             || (dst(iord).getModule() == module && 
                 dst(iord).getLayer() == layer && 
                 dst(iord).getSector() < sector))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() || dst(iord).getModule() != module ||
                                dst(iord).getLayer() != layer ||
                                dst(iord).getSector() != sector)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setModule(module);
         dst(iord).setLayer(layer);
         dst(iord).setSector(sector);
      }
      dst(iord).getBcalfADCDigiHits() += iter->getBcalfADCDigiHits();
      dst(iord).getBcalTDCDigiHits() += iter->getBcalTDCDigiHits();
      dst(iord).getBcalfADCHits() += iter->getBcalfADCHits();
      dst(iord).getBcalTDCHits() += iter->getBcalTDCHits();
   }
   return dst;
}

hddm_s::BcalfADCHitList &operator+=(hddm_s::BcalfADCHitList &dst,
                                    hddm_s::BcalfADCHitList &src)
{
   // order by end, t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::BcalfADCHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = bcal_min_delta_t_ns;
      double newE = iter->getE();
      int end = iter->getEnd();
      while (iord > 0) {
         if (iord == dst.size() ||
             dst(iord).getEnd() > end || dst(iord).getT() > t)
         {
            --iord;
         }
         else
           break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getEnd() < end || dst(iord).getT() < t) {
            ++iord;
         }
         else
            break;
      }
      if (iord > 0 &&
          dst(iord - 1).getEnd() == end && t - dst(iord - 1).getT() < dt)
      {
         double oldE = dst(iord - 1).getE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setE(oldE + newE * pulse_fraction);
      }
      else if (iord < dst.size() &&
               dst(iord).getEnd() == end && dst(iord).getT() - t < dt)
      {
         double oldE = dst(iord).getE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setE(newE + oldE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setEnd(end);
         dst(iord).setE(newE);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::BcalTDCHitList &operator+=(hddm_s::BcalTDCHitList &dst,
                                   hddm_s::BcalTDCHitList &src)
{
   // order by end, t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::BcalTDCHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = bcal_min_delta_t_ns;
      int end = iter->getEnd();
      while (iord > 0) {
         if (iord == dst.size() ||
             dst(iord).getEnd() > end || dst(iord).getT() > t)
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if  (dst(iord).getEnd() < end || dst(iord).getT() < t) {
            ++iord;
         }
         else
            break;
      }
      if (iord > 0 && 
          dst(iord - 1).getEnd() == end && t - dst(iord - 1).getT() < dt)
      {
         continue;
      }
      else if (iord < dst.size() &&
               dst(iord).getEnd() == end &&  dst(iord).getT() - t < dt)
      {
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setEnd(end);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::BcalfADCDigiHitList &operator+=(hddm_s::BcalfADCDigiHitList &dst,
                                        hddm_s::BcalfADCDigiHitList &src)
{
   // order by end, t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::BcalfADCDigiHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getPulse_time() + t_shift_ns * fadc_counts_per_ns;
      double dt = bcal_min_delta_t_ns * fadc_counts_per_ns;
      double newE = iter->getPulse_integral();
      int end = iter->getEnd();
      while (iord > 0) {
         if (iord == dst.size() ||
             dst(iord).getEnd() > end || dst(iord).getPulse_time() > t)
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getEnd() < end || dst(iord).getPulse_time() < t) {
            ++iord;
         }
         else
            break;
      }
      if (iord > 0 && dst(iord - 1).getEnd() == end &&
                      t - dst(iord - 1).getPulse_time() < dt)
      {
         double oldE = dst(iord - 1).getPulse_integral();
         double pulse_fraction = 1 - (t - dst(iord - 1).getPulse_time()) / dt;
         dst(iord - 1).setPulse_integral(oldE + newE * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getEnd() == end &&
                                    dst(iord).getPulse_time() - t < dt)
      {
         double oldE = dst(iord).getPulse_integral();
         double pulse_fraction = 1 - (dst(iord - 1).getPulse_time() - t) / dt;
         dst(iord).setPulse_integral(newE + oldE * pulse_fraction);
         dst(iord).setPulse_time(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setEnd(end);
         dst(iord).setPulse_integral(newE);
         dst(iord).setPulse_time(t);
      }
   }
   return dst;
}

hddm_s::BcalTDCDigiHitList &operator+=(hddm_s::BcalTDCDigiHitList &dst,
                                        hddm_s::BcalTDCDigiHitList &src)
{
   // order by end, t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::BcalTDCDigiHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getTime() + t_shift_ns * tdc_counts_per_ns;
      double dt = bcal_min_delta_t_ns * tdc_counts_per_ns;
      int end = iter->getEnd();
      while (iord > 0) {
         if (iord == dst.size() ||
             dst(iord).getEnd() > end || dst(iord).getTime() > t)
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getEnd() < end || dst(iord).getTime() < t) {
            ++iord;
         }
         else
            break;
      }
      if (iord > 0 && 
          dst(iord - 1).getEnd() == end && t - dst(iord - 1).getTime() < dt)
      {
         continue;
      }
      else if (iord < dst.size() &&
               dst(iord).getEnd() == end &&  dst(iord).getTime() - t < dt)
      {
         dst(iord).setTime(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setEnd(end);
         dst(iord).setTime(t);
      }
   }
   return dst;
}

hddm_s::ForwardTOFList &operator+=(hddm_s::ForwardTOFList &dst,
                                   hddm_s::ForwardTOFList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::ForwardTOFList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getFtofCounters() += iter->getFtofCounters();
   }
   return dst;
}

hddm_s::FtofCounterList &operator+=(hddm_s::FtofCounterList &dst,
                                    hddm_s::FtofCounterList &src)
{
   // order first by plane, then bar
   int iord = 0;
   hddm_s::FtofCounterList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int bar = iter->getBar();
      int plane = iter->getPlane();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getPlane() > plane ||
             (dst(iord).getPlane() == plane && dst(iord).getBar() > bar))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getPlane() < plane ||
             (dst(iord).getPlane() == plane && dst(iord).getBar() < bar))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() ||
          dst(iord).getPlane() != plane || 
          dst(iord).getBar() != bar)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setPlane(plane);
         dst(iord).setBar(bar);
      }
      dst(iord).getFtofHits() += iter->getFtofHits();
   }
   return dst;
}

hddm_s::FtofHitList &operator+=(hddm_s::FtofHitList &dst,
                                hddm_s::FtofHitList &src)
{
   // order by end, t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::FtofHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = ftof_min_delta_t_ns;
      double newDE = iter->getDE();
      int end = iter->getEnd();
      while (iord > 0) {
         if (iord == dst.size() ||
             dst(iord).getEnd() > end || dst(iord).getT() > t)
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getEnd() < end || dst(iord).getT() < t) {
            ++iord;
         }
         else
            break;
      }
      if (iord > 0 && 
          dst(iord - 1).getEnd() == end && t - dst(iord - 1).getT() < dt)
      {
         double oldDE = dst(iord - 1).getDE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setDE(oldDE + newDE * pulse_fraction);
      }
      else if (iord < dst.size() && 
               dst(iord).getEnd() == end && dst(iord).getT() - t < dt)
      {
         double oldDE = dst(iord).getDE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setDE(newDE + oldDE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setEnd(end);
         dst(iord).setDE(newDE);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::ForwardEMcalList &operator+=(hddm_s::ForwardEMcalList &dst,
                                     hddm_s::ForwardEMcalList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::ForwardEMcalList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getFcalBlocks() += iter->getFcalBlocks();
   }
   return dst;
}

hddm_s::FcalBlockList &operator+=(hddm_s::FcalBlockList &dst,
                                  hddm_s::FcalBlockList &src)
{
   // order first by column, then row
   int iord = 0;
   hddm_s::FcalBlockList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int row = iter->getRow();
      int column = iter->getColumn();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getColumn() > column ||
             (dst(iord).getColumn() == column && dst(iord).getRow() > row))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getColumn() < column ||
             (dst(iord).getColumn() == column && dst(iord).getRow() < row))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() ||
          dst(iord).getColumn() != column || 
          dst(iord).getRow() != row)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setColumn(column);
         dst(iord).setRow(row);
      }
      dst(iord).getFcalHits() += iter->getFcalHits();
   }
   return dst;
}

hddm_s::FcalHitList &operator+=(hddm_s::FcalHitList &dst,
                                hddm_s::FcalHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::FcalHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = fcal_min_delta_t_ns;
      double newE = iter->getE();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldE = dst(iord - 1).getE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setE(oldE + newE * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldE = dst(iord).getE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setE(newE + oldE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setE(newE);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::ComptonEMcalList &operator+=(hddm_s::ComptonEMcalList &dst,
                                     hddm_s::ComptonEMcalList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::ComptonEMcalList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getCcalBlocks() += iter->getCcalBlocks();
   }
   return dst;
}

hddm_s::CcalBlockList &operator+=(hddm_s::CcalBlockList &dst,
                                  hddm_s::CcalBlockList &src)
{
   // order first by column, then row
   int iord = 0;
   hddm_s::CcalBlockList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int row = iter->getRow();
      int column = iter->getColumn();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getColumn() > column ||
             (dst(iord).getColumn() == column && dst(iord).getRow() > row))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getColumn() < column ||
             (dst(iord).getColumn() == column && dst(iord).getRow() < row))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() ||
          dst(iord).getColumn() != column || 
          dst(iord).getRow() != row)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setColumn(column);
         dst(iord).setRow(row);
      }
      dst(iord).getCcalHits() += iter->getCcalHits();
   }
   return dst;
}

hddm_s::CcalHitList &operator+=(hddm_s::CcalHitList &dst,
                                hddm_s::CcalHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::CcalHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = ccal_min_delta_t_ns;
      double newE = iter->getE();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldE = dst(iord - 1).getE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setE(oldE + newE * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldE = dst(iord).getE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setE(newE + oldE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setE(newE);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::TaggerList &operator+=(hddm_s::TaggerList &dst,
                               hddm_s::TaggerList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::TaggerList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getMicroChannels() += iter->getMicroChannels();
      dst(0).getHodoChannels() += iter->getHodoChannels();
   }
   return dst;
}

hddm_s::MicroChannelList &operator+=(hddm_s::MicroChannelList &dst,
                                     hddm_s::MicroChannelList &src)
{
   // order by column, row index
   int iord = 0;
   hddm_s::MicroChannelList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int column = iter->getColumn();
      int row = iter->getRow();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getColumn() > column ||
             (dst(iord).getColumn() == column && dst(iord).getRow() > row))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getColumn() < column ||
             (dst(iord).getColumn() == column && dst(iord).getRow() < row))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() || dst(iord).getColumn() != column ||
                                dst(iord).getRow() != row)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setColumn(column);
         dst(iord).setRow(row);
         dst(iord).setE(iter->getE());
      }
      dst(iord).getTaggerHits() += iter->getTaggerHits();
   }
   return dst;
}

hddm_s::HodoChannelList &operator+=(hddm_s::HodoChannelList &dst,
                                    hddm_s::HodoChannelList &src)
{
   // order by counter index
   int iord = 0;
   hddm_s::HodoChannelList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int cid = iter->getCounterId();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getCounterId() > cid)
            --iord;
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getCounterId() < cid)
            ++iord;
         else
            break;
      }
      if (iord == dst.size() || dst(iord).getCounterId() != cid) {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setCounterId(cid);
         dst(iord).setE(iter->getE());
      }
      dst(iord).getTaggerHits() += iter->getTaggerHits();
   }
   return dst;
}

hddm_s::TaggerHitList &operator+=(hddm_s::TaggerHitList &dst,
                                  hddm_s::TaggerHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::TaggerHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = ttag_min_delta_t_ns;
      double newNpe = iter->getNpe();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldNpe = dst(iord - 1).getNpe();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setNpe(oldNpe + newNpe * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldNpe = dst(iord).getNpe();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setNpe(newNpe + oldNpe * pulse_fraction);
         dst(iord).setTADC(iter->getTADC());
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setNpe(newNpe);
         dst(iord).setTADC(iter->getTADC());
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::PairSpectrometerFineList &operator+=(
                                 hddm_s::PairSpectrometerFineList &dst,
                                 hddm_s::PairSpectrometerFineList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::PairSpectrometerFineList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getPsTiles() += iter->getPsTiles();
   }
   return dst;
}

hddm_s::PsTileList &operator+=(hddm_s::PsTileList &dst,
                               hddm_s::PsTileList &src)
{
   // order first by arm, then column
   int iord = 0;
   hddm_s::PsTileList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int column = iter->getColumn();
      int arm = iter->getArm();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getArm() > arm ||
             (dst(iord).getArm() == arm && dst(iord).getColumn() > column))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getArm() < arm ||
             (dst(iord).getArm() == arm && dst(iord).getColumn() < column))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() ||
          dst(iord).getArm() != arm || 
          dst(iord).getColumn() != column)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setArm(arm);
         dst(iord).setColumn(column);
      }
      dst(iord).getPsHits() += iter->getPsHits();
   }
   return dst;
}

hddm_s::PsHitList &operator+=(hddm_s::PsHitList &dst,
                              hddm_s::PsHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::PsHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = ps_min_delta_t_ns;
      double newDE = iter->getDE();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldDE = dst(iord - 1).getDE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setDE(oldDE + newDE * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldDE = dst(iord).getDE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setDE(newDE + oldDE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setDE(newDE);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::PairSpectrometerCoarseList &operator+=(
                              hddm_s::PairSpectrometerCoarseList &dst,
                              hddm_s::PairSpectrometerCoarseList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::PairSpectrometerCoarseList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getPscPaddles() += iter->getPscPaddles();
   }
   return dst;
}

hddm_s::PscPaddleList &operator+=(hddm_s::PscPaddleList &dst,
                                  hddm_s::PscPaddleList &src)
{
   // order first by arm, then module
   int iord = 0;
   hddm_s::PscPaddleList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int module = iter->getModule();
      int arm = iter->getArm();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getArm() > arm ||
             (dst(iord).getArm() == arm && dst(iord).getModule() > module))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getArm() < arm ||
             (dst(iord).getArm() == arm && dst(iord).getModule() < module))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() ||
          dst(iord).getArm() != arm || 
          dst(iord).getModule() != module)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setArm(arm);
         dst(iord).setModule(module);
      }
      dst(iord).getPscHits() += iter->getPscHits();
   }
   return dst;
}

hddm_s::PscHitList &operator+=(hddm_s::PscHitList &dst,
                               hddm_s::PscHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::PscHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = psc_min_delta_t_ns;
      double newDE = iter->getDE();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldDE = dst(iord - 1).getDE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setDE(oldDE + newDE * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldDE = dst(iord).getDE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setDE(newDE + oldDE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setDE(newDE);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::TripletPolarimeterList &operator+=(
                                  hddm_s::TripletPolarimeterList &dst,
                                  hddm_s::TripletPolarimeterList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::TripletPolarimeterList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getTpolSectors() += iter->getTpolSectors();
   }
   return dst;
}

hddm_s::TpolSectorList &operator+=(hddm_s::TpolSectorList &dst,
                                   hddm_s::TpolSectorList &src)
{
   // order by sector index
   int iord = 0;
   hddm_s::TpolSectorList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int sector = iter->getSector();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getSector() > sector)
            --iord;
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getSector() < sector)
            ++iord;
         else
            break;
      }
      if (iord == dst.size() || dst(iord).getSector() != sector) {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setSector(sector);
      }
      dst(iord).getTpolHits() += iter->getTpolHits();
   }
   return dst;
}

hddm_s::TpolHitList &operator+=(hddm_s::TpolHitList &dst,
                                hddm_s::TpolHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::TpolHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = tpol_min_delta_t_ns;
      double newDE = iter->getDE();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldDE = dst(iord - 1).getDE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setDE(oldDE + newDE * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldDE = dst(iord).getDE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setDE(newDE + oldDE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setDE(newDE);
         dst(iord).setT(t);
      }
   }
   return dst;
}

hddm_s::ForwardMWPCList &operator+=(hddm_s::ForwardMWPCList &dst,
                                    hddm_s::ForwardMWPCList &src)
{
   if (src.size() > 0 && dst.size() == 0)
      dst.add(1);
   hddm_s::ForwardMWPCList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      dst(0).getFmwpcChambers() += iter->getFmwpcChambers();
   }
   return dst;
}

hddm_s::FmwpcChamberList &operator+=(hddm_s::FmwpcChamberList &dst,
                                     hddm_s::FmwpcChamberList &src)
{
   // order first by layer, then wire
   int iord = 0;
   hddm_s::FmwpcChamberList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      int layer = iter->getLayer();
      int wire = iter->getWire();
      while (iord > 0) {
         if (iord == dst.size() || dst(iord).getLayer() > layer ||
             (dst(iord).getLayer() == layer && dst(iord).getWire() > wire))
         {
            --iord;
         }
         else
            break;
      }
      while (iord < dst.size()) {
         if (dst(iord).getLayer() < layer ||
             (dst(iord).getLayer() == layer && dst(iord).getWire() < wire))
         {
            ++iord;
         }
         else
            break;
      }
      if (iord == dst.size() ||
          dst(iord).getLayer() != layer || 
          dst(iord).getWire() != wire)
      {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setLayer(layer);
         dst(iord).setWire(wire);
      }
      dst(iord).getFmwpcHits() += iter->getFmwpcHits();
   }
   return dst;
}

hddm_s::FmwpcHitList &operator+=(hddm_s::FmwpcHitList &dst,
                                 hddm_s::FmwpcHitList &src)
{
   // order by t, merge with existing hit if dt < dtmin
   int iord = 0;
   hddm_s::FmwpcHitList::iterator iter;
   for (iter = src.begin(); iter != src.end(); ++iter) {
      double t = iter->getT() + t_shift_ns;
      double dt = fmwpc_min_delta_t_ns;
      double newDE = iter->getDE();
      while (iord > 0 && dst(iord).getT() > t)
         --iord;
      while (iord < dst.size() && dst(iord).getT() < t)
         ++iord;
      if (iord > 0 && t - dst(iord - 1).getT() < dt) {
         double oldDE = dst(iord - 1).getDE();
         double pulse_fraction = 1 - (t - dst(iord - 1).getT()) / dt;
         dst(iord - 1).setDE(oldDE + newDE * pulse_fraction);
      }
      else if (iord < dst.size() && dst(iord).getT() - t < dt) {
         double oldDE = dst(iord).getDE();
         double pulse_fraction = 1 - (dst(iord - 1).getT() - t) / dt;
         dst(iord).setDE(newDE + oldDE * pulse_fraction);
         dst(iord).setT(t);
      }
      else {
         dst.add(1, (iord < dst.size())? iord : -1);
         dst(iord).setDE(newDE);
         dst(iord).setT(t);
      }
   }
   return dst;
}
